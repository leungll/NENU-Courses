/*
 * Mathematics C test harness
 * Copyright (C) ARM Limited 1998-1999. All rights reserved.
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#include "mathtesc.h"
#include "mathtess.h"

#include "custredc.h"
#include "definesc.h"
#include "fileutlc.h"
#include "optionsc.h"

#define	MATHS_OPTIONS	1

typedef struct	IOType	IOType ;
typedef			IOType	*IOTypePtr ;

struct IOType {
	int	arg1size ;	/* size in bits of argument */
	int arg1q ;		/* position of floating point for fixed point operations */
	int arg2size ;
	int arg2q ;
	int out1size ;
	int out1q ;
	int out2size ;
	int out2q ;
} ;
/* define the IO structure used for testing */

static IOType	io_standard2	= { 32,  0, 32,  0,  32,  0,  0,  0 } ;
/* two 32-bit inputs, one 32-bit result - standard type */
static IOType	io_32x32_64		= { 32,  0, 32,  0,  64,  0,  0,  0 } ;
/* two 32-bit inputs, one 64-bit result */
static IOType	io_64x64_64		= { 64,  0, 64,  0,  64,  0,  0,  0 } ;
/* two 64-bit inputs, one 64-bit result */
static IOType	io_64x64_128	= { 64,  0, 64,  0, 128,  0,  0,  0 } ;
/* two 64-bit inputs, one 128-bit result */
static IOType	io_32d32_32r32	= { 32,  0, 32,  0,  32,  0, 32,  0 } ;
/* two 32-bit inputs, one 32-bit quotient & one 32-bit remainder result */
static IOType	io_64d32_32r32	= { 64,  0, 32,  0,  32,  0, 32,  0 } ;
/* one 64-bit, one 32-bit input, one 32-bit quotient & one 32-bit remainder */
static IOType	io_64d64_64r64	= { 64,  0, 64,  0,  64,  0, 64,  0 } ;
/* two 64-bit inputs, one 64-bit quotient & one 64-bit remainder */
static IOType	io_s32_32r32	= { 32,  0,  0,  0,  32,  0, 32,  0 } ;
/* one 32-bit input, one 32-bit quotient & one 32-bit remainder */
static IOType	io_c32_32		= { 32,  0,  0,  0,  32,  0,  0,  0 } ;
/* one 32-bit input, one 32-bit output */
static IOType	io_32d32_f32	= { 32,  0, 32,  0,  32, 16,  0,  0 } ;
/* two 32-bit inputs, one 32-bit quotient with 16-bit fixed decimal point */
static IOType	io_csf32_f32	= { 32, 14,  0,  0,  32, 14,  0,  0 } ;
/* one 32-bit input with 14-bit fixed decimal point, one 32-bit output with 14-bit fixed decimal point */

static Boolean MathsTest( unsigned int option ) ;
static void Menu( unsigned int numberOptions ) ;
static void RetrieveOutput( u32 *buff, int size, int q, int sign ) ;
static int SignedSaturation( int value1, int value2 ) ;

/**** RUNMATHS **********************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * macro to call each of the maths macros in turn after initialising the argument list,
 * passing the created arguments, retrieving the outputs and printing the results back
 *
 * Inputs
 * ------
 *   MATHSNAME
 *   - the name of the maths macro to call (case sensitive = actual macro name)
 *   IOTYPE
 *   - the IOType structure for the macro call to make up arguments
 *   NUMBER1, NUMBER2
 *   - the numbers to be broken into 32bit parts and passed to macros
 *   ARG1, ARG2
 *   - initialised arrays of unsigned integers to hold the x*32-bit values for each
 *     number respectively and post macro call the results of the macro
 *   ACTUALRESULT
 *   - an integer containing the expected result generated by some other method
 *   SIGN
 *   - 1 : print back the negative output result if top bit of output is set
 *     0 : print back the positive output result
 * Outputs
 * -------
 *   ARG1, ARG2
 *   - arrays of 32bit chunks that contain the output results in x*32bit format
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
#define PRERUN( NAME ) { \
	printf( "Testing function %s\n", #NAME ) ; \
}

#define POSTRUN( CRESULT ) { \
	printf( "\n C result = %g\n\n", ( double )CRESULT ) ; \
}

#define RUNMATHS( MATHSNAME, IO_TYPE, NUMBER1, NUMBER2, ARG1, ARG2, CRESULT, SIGN ) { \
	PRERUN( MATHSNAME ) ; \
	InitInputs( &IO_TYPE, NUMBER1, NUMBER2, ARG1, ARG2 ) ; \
	init_##MATHSNAME( ARG1, ARG2 ) ; \
	GetOutputs( &IO_TYPE, ARG1, ARG2, SIGN ) ; \
	POSTRUN( CRESULT ) ; \
}

/**** GetOutputs ********************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * break down the given arguments into 32 bit chunks and print the values either the
 * value as a positive result or (possible) negative result if signed result according
 * to value in given parameter and whether the top most bit of the result is set
 *
 * Inputs
 * ------
 *   ioTypePtr
 *   - a pointer to an IOType that contains the information about data for the
 *     two arguments given
 *   arg1
 *   - pointer to array of u32's that holds the first output result
 *   arg2
 *   - pointer to array of u32's that holds the second output result
 *   actualResult
 *   - the expected result obtained from some other means (such as C based routines)
 *   sign
 *   - 1 : print back the negative output result if top bit of output is set
 *     0 : print back the positive output result
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
static void GetOutputs( IOTypePtr ioTypePtr, u32 *arg1, u32 *arg2, int sign )
{
	RetrieveOutput( arg1, ioTypePtr->out1size, ioTypePtr->out1q, sign ) ;
	RetrieveOutput( arg2, ioTypePtr->out2size, ioTypePtr->out2q, sign ) ;
}

/**** InitArg ***********************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * extract each 32 bits from the given number and place them into the array given
 * and print the current 32-bits out to the screen
 *
 * Inputs
 * ------
 *   arg
 *   - an initialised array of unsigned integers to hold the x*32-bit value
 *   number
 *   - the value to add split over 32-bit chunks and add to arg as given by user
 *   size
 *   - total number of bits that are to be in argument = x*32bit value (ensures
 *     that negative values are correctly sign extended over whole bit range)
 *   q
 *   - position of decimal point for fixed point operations (0 for integers)
 * Outputs
 * -------
 *   arg
 *   - an array of 32bit chunks that contains the number in x*32bit format
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
static void InitArg( u32 *arg, double number, int size, int q )
{
	int		archSize = 32 ;	/* 32-bit integer architecture (default) */
	double	factor32 = ( double ) 65536 * 65536 ;	/* 2^16 x 2^16 = 2^32, 32-bit factor */
	u32		eor = 0 ;	/* exclusive OR to enable use of +ve algorithm for -ve values */
	u32		intNumber ;
  
	if( size == 0 ) {
		*arg = 0 ;
  		return ;
	}
	
	number *= ( double )( ( int )( 1 << q ) ) ; /* shift decimal point accordingly */

	if( number < 0 ) {
		number = -1-number ; /* ie NOT(number) to use postive algorithm */
    	eor = 0xffffffff ;	/* set up exclusive OR to convert back */
	}
			
	while( archSize < size ) {
    	archSize += 32 ;
    	number = number / factor32 ;	/* reduce given number by 32-bits */
    	arg += 1 ;	/* increment the argument array, since lowest sig bit first */
  	}

	printf( " argument = " );
					   
	while( archSize > 0 ) {
    	intNumber = ( u32 )number ;	/* discard the fractional part of number */
    	number = number - ( double )intNumber ;	/* get the fractional part of number */
    	number = number * factor32 ;	/* shift fractional part into next 32-bit range */
    	intNumber = intNumber ^ eor ;	/* exclusive OR int number to count for -ve case */
    	*arg-- = intNumber ;	/* add adjusted int number into 32-bit argument array */
    	printf( "0x%08x ", intNumber ) ;
    	archSize -= 32 ;
	}

	printf("\n");
}

/**** InitInputs ********************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * extract each 32 bits from the given numbers and place them into their respective
 * array given and print the current 32-bits out to the screen
 *
 * Inputs
 * ------
 *   ioTypePtr
 *   - a pointer to an IOType that contains information about the arguments to be
 *     constructed
 *   number1, number2
 *   - the numbers to be broken into 32bit chunks and added to given arrays
 *   arg1, arg2
 *   - initialised arrays of unsigned integers to hold the x*32-bit values for each
 *     number respectively
 * Outputs
 * -------
 *   arg1, arg2
 *   - arrays of 32bit chunks that contain the numbers in x*32bit format
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
static void InitInputs( IOTypePtr ioTypePtr, double number1, double number2, u32 *arg1, u32 *arg2 )
{
	InitArg( arg1, number1, ioTypePtr->arg1size, ioTypePtr->arg1q ) ;
	InitArg( arg2, number2, ioTypePtr->arg2size, ioTypePtr->arg2q ) ;
}

/**** math_main *********************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * initialise the application then loop whilst the user is still working
 *
 * Return Values
 * ------ ------
 *     0 - application terminated correctly
 *     1 - some error occurred
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
int math_main( int argc, char **argv )
{
	unsigned int	option ;
	char			newStdIn[ ] = "stdin" ;
	char			newStdOut[ ] = "stdout" ;
	char			newStdErr[ ] = "stderr" ;
	unsigned int	stdio = 0 ;
	
	if( ChangeStdIO( &argc, &argv, newStdIn, stdin ) == STDINID ) {
		stdio |= ( 1 << STDINID ) ;
	}
	if( ChangeStdIO( &argc, &argv, newStdOut, stdout ) == STDOUTID ) {
		stdio |= ( 1 << STDOUTID ) ;
	}
	if( ChangeStdIO( &argc, &argv, newStdErr, stderr ) == STDERRID ) {
		stdio |= ( 1 << STDERRID ) ;
	}
	
	while( 1 ) {
		if( ( option = NextTask( MATHS_OPTIONS, &Menu ) ) == 0 ) {
			break ;
		}
		
		MathsTest( option ) ;
	}
	
	/* redirection based on trying to open files that don't exist do using defaults */
	if( stdio & ( 1 << STDINID ) ) {
		ResetStdIO( stdin ) ;
	}
	if( stdio & ( 1 << STDOUTID ) ) {
		ResetStdIO( stdout ) ;
	}
	if( stdio & ( 1 << STDERRID ) ) {
		ResetStdIO( stderr ) ;
	}
		
	return 0 ;
}

/**** MathsTest *********************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * ask the user for two numbers and pass these through to each of the
 * macro instantiations in turn printing the output back
 *
 * Inputs
 * ------
 *   option
 *   - reserved for future use
 * Return Values
 * ------ ------
 *     TRUE	 - bit testing completed correctly
 *     FALSE - some error occurred
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
static Boolean MathsTest( unsigned int option )
{
	double			number1 ;
	double			number2 ;
	unsigned int	uiN1 ;
	signed int		siN1 ;
	unsigned int	uiN2 ;
	signed int		siN2 ;
	unsigned short	usN1 ;
	signed short	ssN1 ;
	unsigned short	usN2 ;
	signed short	ssN2 ;
	double			uiMultiplied ;
	double			siMultiplied ;
	unsigned int	uiDivided ;
	signed int		siDivided ;
	unsigned short	usDiv16 ;
	signed short	ssDiv16 ;
	double			ufDivided ;
	double			sfDivided ;
	u32				arg1[ 4 ] ;
	u32				arg2[ 4 ] ;
	
	if( option > MATHS_OPTIONS ) {
		fprintf( stderr, "[MathsTest] Error in arguments, aborting.\n\n" ) ;
		/* function name given since intended as internal error for programmer */
		return FALSE ;
	}

	for( siN1 = 0 ; siN1 < 4 ; siN1 += 1 ) {
		/* reset arguments */
		arg1[ siN1 ] = 0 ;
		arg2[ siN1 ] = 0 ;
	}

	printf( "Please enter two values for Maths Macros testing.\n\n" ) ;
	
	printf( "The first number corresponds to the numerator during division and\n" ) ;
	printf( "the value passed to the square root, cube root, cosine and sine functions.\n\n" ) ;
	
	printf( "Some routines may not return the expected values during testing if the values\n" ) ;
	printf( "given for testing do not obey the rules governing values passed to the functions.\n\n" ) ;
	
	printf( "Enter the first number: " ) ;
	number1 = ReadDouble( ) ;

	if( number1 < 0 ) {
		uiN1 = 0xFFFFFFFFu + ( signed int )number1 + 1 ;
		usN1 = ( unsigned short )( 0xFFFFu + number1 + 1 ) ;
	}
	else {
		uiN1 = ( unsigned int )number1 ;
		usN1 = ( unsigned short )number1 ;
	}
	siN1 = ( signed int )number1 ;
	ssN1 = ( signed short )number1 ;
	
	printf( "Enter the second number: " ) ;
	number2 = ReadDouble( ) ;

	if( number2 < 0 ) {
		uiN2 = 0xFFFFFFFFu + ( signed int )number2 + 1 ;
		usN2 = ( unsigned short )( 0xFFFFu + number2 + 1 ) ;
	}
	else {
		uiN2 = ( unsigned int )number2 ;
		usN2 = ( unsigned short )number2 ;
	}
	siN2 = ( signed int )number2 ;
	ssN2 = ( signed short )number2 ;
	
	printf( "For testing all the routines except the cosine and sine functions, the numbers used\n" ) ;
	printf( "are the integer parts of the any floating point numbers given, whilst the fractional\n" ) ;
	printf( "part is maintained for testing the cosine and sine functions.\n\n" ) ;
	
	printf( "Values given are '%d' & '%d'\n\n", siN1, siN2 ) ;
	
	printf( "Note that the cosine and sine tests are calculated based on a fixed point precision,\n" ) ;
	printf( "which is set as 14 using the actual decimal values '%lf' & '%lf'\n\n", number1, number2 ) ;
	
	if( number2 == 0 ) {
		printf( "The division routines will not be tested since the second number is 0.\n\n" ) ;
	}
	
	printf( "Starting test...\n\n" ) ;
	
	uiMultiplied = ( double )uiN1*( double )uiN2 ;
	siMultiplied = ( double )siN1*( double )siN2 ;
	if( number2 != 0 ) {
		usDiv16 = ( unsigned short )( ( uiN1 )/( unsigned int )( usN2 ) ) ;
		ssDiv16 = ( signed short )( ( siN1 )/( signed int )( ssN2 ) ) ;
		uiDivided = ( unsigned int )( ( uiN1 )/( uiN2 ) ) ;
		ufDivided = ( double )( uiN1 )/( double )( uiN2 ) ;
		siDivided = ( signed int )( ( siN1 )/( siN2 ) ) ;
		sfDivided = ( double )( siN1 )/( double )( siN2 ) ;
	}
	else {
		usDiv16 = 0 ;
		ssDiv16 = 0 ;
		ufDivided = 0 ;
		uiDivided = 0 ;
		sfDivided = 0 ;
		siDivided = 0 ;
	}
	
	RUNMATHS( ADDABS, io_standard2, siN1, siN2, arg1, arg2, siN1+abs( siN2 ), 1 ) ;
	RUNMATHS( SIGNSAT, io_standard2, siN1, siN2, arg1, arg2, SignedSaturation( siN1, siN2 ), 1 ) ;		

	RUNMATHS( UMUL_32x32_64, io_32x32_64, uiN1, uiN2, arg1, arg2, uiMultiplied, 0 ) ;
	RUNMATHS( SMUL_32x32_64, io_32x32_64, siN1, siN2, arg1, arg2, siMultiplied, 1 ) ;
	RUNMATHS( MUL_64x64_64, io_64x64_64, siN1, siN2, arg1, arg2, siMultiplied, 1 ) ;
	RUNMATHS( UMUL_64x64_128, io_64x64_128, uiN1, uiN2, arg1, arg2, uiMultiplied, 0 ) ;
	
	RUNMATHS( SMUL_64x64_128, io_64x64_128, siN1, siN2, arg1, arg2, siMultiplied, 1 ) ;
	
	if( number2 != 0 ) {
		RUNMATHS( UDIV_32d16_16r16, io_32d32_32r32, uiN1, usN2, arg1, arg2, usDiv16, 0 ) ;
		RUNMATHS( SDIV_32d16_16r16, io_32d32_32r32, siN1, ssN2, arg1, arg2, ssDiv16, 1 ) ;
		RUNMATHS( UDIV_32d32_32r32, io_32d32_32r32, uiN1, uiN2, arg1, arg2, uiDivided, 0 ) ;
		RUNMATHS( SDIV_32d32_32r32, io_32d32_32r32, siN1, siN2, arg1, arg2, siDivided, 1 ) ;
		RUNMATHS( UDIV_64d32_32r32, io_64d32_32r32, uiN1, uiN2, arg1, arg2, uiDivided, 0 ) ;
		RUNMATHS( SDIV_64d32_32r32, io_64d32_32r32, siN1, siN2, arg1, arg2, siDivided, 1 ) ;
		RUNMATHS( UDIV_64d64_64r64, io_64d64_64r64, uiN1, uiN2, arg1, arg2, uiDivided, 0 ) ;
		RUNMATHS( SDIV_64d64_64r64, io_64d64_64r64, siN1, siN2, arg1, arg2, siDivided, 1 ) ;
	}
	
	RUNMATHS( SQR_32_16r17, io_s32_32r32, uiN1, uiN2, arg1, arg2, ( int )sqrt( uiN1 ), 0 ) ;
	RUNMATHS( CBR_32_11, io_c32_32, uiN1, uiN2, arg1, arg2, ( int )( floor( pow( uiN1, 1.0/3.0 ) + 0.5 ) ), 0 ) ;
	
	if( number2 != 0 ) {
		RUNMATHS( UDIVF_32d32_32, io_32d32_f32, uiN1, uiN2, arg1, arg2, ufDivided, 0 ) ;
		RUNMATHS( SDIVF_32d32_32, io_32d32_f32, siN1, siN2, arg1, arg2, sfDivided, 1 ) ;
	}
	
	RUNMATHS( ARMCOS, io_csf32_f32, number1, number2, arg1, arg2, cos( number1 ), 1 ) ;
	RUNMATHS( ARMSIN, io_csf32_f32, number1, number2, arg1, arg2, sin( number1 ), 1 ) ;
	
	printf( "Test completed.\n\n" ) ;
	
	return TRUE ;
}

/**** Menu **************************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * print the menu of options to the screen (defined in standard way for NextTask 
 * function and will be called by NextTask)
 *
 * Inputs
 * ------
 *   numberOptions
 *   - the number of menu options that should be printed
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
static void Menu( unsigned int numberOptions )
{
	if( numberOptions == MATHS_OPTIONS ) {
		printf( " 1. Test mathematics routines.\n" ) ;
	}
	else {
		fprintf( stderr, "[Menu] Error in arguments, aborting.\n\n" ) ;
		/* function name given since intended as internal error for programmer */
	}
}

/**** RetrieveOutput ****************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * extract each 32 bits from the given argument and print the value either the
 * value as a positive result or negative result according to the value of a parameter
 * given and whether the top most bit of the result is set
 *
 * Inputs
 * ------
 *   arg
 *   - array of unsigned integers making up the x*32-bit value
 *   size
 *   - total number of bits in argument = x*32bit value
 *   q
 *   - position of decimal point for fixed point operations (0 for integers)
 *   sign
 *   - 1 : print back the negative output result if top bit of output is set
 *     0 : print back the positive output result
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
static void RetrieveOutput( u32 *arg, int size, int q, int sign )
{
	double	factor32 = ( double )65536 * 65536 ;	/* 2^16 x 2^16 = 2^32, 32-bit factor */
	u32		intNumber ;
	double	nans = 0 ;
	double	pans = 0 ;
	int		archSize = 0 ;
	int		isNegative = 0 ;
	int		notTested = 1 ;
  
	if( size == 0 ) {
  		return ;
	}

	while( archSize < size ) {
    	intNumber = *arg++ ;	/* read first 32-bit part from argument array */
    
    	nans += ( double )( ( int )( ~intNumber ) ) ;	/* NOT int number for negative result */
    	pans += ( double )intNumber ;
    	archSize += 32 ;
    	nans /= factor32 ;
    	pans /= factor32 ;
  	}		
  
	printf( " result   = " ) ;

	while( size > 0 ) {
    	arg -= 1 ;
    	printf( "0x%08x ", *arg ) ;
    	if( sign && notTested ) {
    		isNegative = *arg & 0x80000000 ;
    		notTested = 0 ;
    	}
    	size -= 32 ;
    	nans = nans * factor32 ;
    	pans = pans * factor32 ;
  	}

	factor32 = ( double )( ( int )( 1 << q ) ) ;	/* shift decimal point accordingly */
	nans = -1-nans ;	/* i.e. NOT( nans ) */
	nans /= factor32 ;
	pans /= factor32 ;
	if( sign && isNegative ) {
		printf( "i.e. %g\n", nans ) ;
	}
	else {
		printf( "i.e. %g\n", pans ) ;
	}
}

/**** SignedSaturation **************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * given two signed numbers, add them together saturating the result
 *
 * Inputs
 * ------
 *   value1, value2
 *   - the two signed numbers to add together
 * Return Values
 * ------ ------
 *     int        - the result of the addition
 *     0x80000000 - if the actual result overflows the negative range
 *     0x7FFFFFFF - if the actual result overflows the positive range
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
static int SignedSaturation( int value1, int value2 )
{
	int	result ;
	
	result = value1 + value2 ;
	if( ( value1 > 0 ) && ( value2 > 0 ) ) {
		if( result < 0 ) {
			result = 0x7FFFFFFF ;
		}
	}
	else if( ( value1 < 0 ) && ( value2 < 0 ) ) {
		if( result > 0 ) {
			result = 0x80000000 ;
		}
	}
	
	return result ;
}

